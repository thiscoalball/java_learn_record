1：客户端和服务器之间通过**串行化的对象**进行通信 （Object）：

​		因为带的信息较多如果用字符串的的形式会造成服务端的处理很麻烦。



2：**多用户通信 创建的socket的要放入到线程中**（客户端和服务端都要**各自启用一个线程**）：

​	（因为多个用户之间的通信需要一直被持有不能被干扰，如果没有线程的话，比如ABCD，A和B，C和D就不能同时讲话）

​		因为没线程的情况下，A和B讲话就会一直占用主线。导致CD不能说话。



3：**服务器端需要有一个管理线程的集合**

​		因为多用户通信线程很多，需要一个专门管理线程的集合

​	   集合里有很多的线程，每个线程里的socket对应一个数据通道。



4：**一个客户端也可能和服务器端创建多个线程连接**

​		 比如客户端A有一个线程用来和服务器传递文件，还有一个线程进行视频通话

​		所以客户端也要有一个集合用来管理线程











**客户端连接到服务端**

登录时发送自己的账号和密码 服务端进行验证   验证后回复一个message对象验证是否登陆成功

为了验证密码和id创建一个服务类—->UserClientService 进行传入进行验证 

验证一旦成功就启用一个线程—————>创建一个线程类——->ClientConnectServerThread

为了方便管理创建——->管理类管理各个线程 ————–>ManageConnectServerThread 



**服务端连接到客户端**基本和上面同理

只是要做校验发回消息

自己写一个HashMap配合静态代码块模拟数据库往里面存入id和pwd

第一次接收用户传过来的User 并校验是否和HashMap里存的一样

一样的话就发回message给客户端   然后把socket放入线程里，开启线程

再把线程放入集合中进行管理



**客户端请求拉取在线用户列表**

在服务类中编写方法

发送一个消息类型（MessageType）：  获取在线用户的消息

​	从管理线程类中 得到该用户线程  从线程类中得到Socket  调用其getOutputStream方法

获取输出流并发送messge

​	在线程类中的run方法里   编写接收   if接收的消息类型是  返回在线用户列表   的话

​	利用message.getContent()

​	将其用空格拆分并用for循环打印



**服务器端发回在线用户列表**

在线程类中的run方法里

​	判断读到的message1类型是不是MESSAGE_GET_ONLINE_FRIEND 是的话输出一行用户的请求

​			在  管理线程类 中 编写方法返回当前在线的用户的线程的消息 集合的迭代器遍历 拼接字符串       

​	回到线程类

​			new 一个 message2   类型为MESSAGE_RET_ONLINE_FRIEND

​    		将 管理线程类 的方法返回的在线用户列表 包装到 setContent 中

​			获取关联的输出流 发送回去



**异常退出解决办法**

在主线程调用方法 给服务器端发送退出系统的message

服务器一端就可以解析这个消息然后关闭线程防止一直等待出现很多异常

主线程调用System.exit(0) 正常退出



**私聊实现**

客户端：

​	接收用户要给哪个人聊天    将消息构建成对象 通过对应的socket发送服务器

​	在客户端接收的线程中 读取发送的消息并显示（否则你发了别人无法显示，别人发给你你也看不到）

服务器：

​	读取到客户端要发送给某个客户    在  管理集合类  中查找有无这个线程   有的话 就获取对应的线程

​	然后将message对象转发给指定用户



**群聊实现**

客户端：

​	客户端发送方发送群聊消息包给服务器

​	客户端接收方接收服务器发送的群聊消息包

服务器：

​	读取处理群聊消息包，查找库中的人员进行转发，转发给除了发送者以外的所有人员

​	通过遍历集合的方式



**文件传输**

客户端：

​	发送方：把文件从磁盘读到客户端转化成字节数组

​							byte[] fileBytes = new byte[(int) (new File(src).length())];

​							fileInputStream = new FileInputStream(src);
​							//将src文件读入到一个字节数组当中并传入自己的消息里
​							fileInputStream.read(fileBytes);
​							message.setFileBytes(fileBytes);

​					把文件对应的字节对象封装到message传输    将message对象发送给客户端 

​					message包括文件内容日期收发双方

​	接收方：接收到文件的消息后，就将该文件保存到磁盘要保存的路径当中



服务端：

​	接收到文件 拆解出message的id，根据id在集合中获得通信线程再得到socket进行转发



**服务器推送**

​	本质其实就是一个群发

​	在服务器端启动一个**独立的线程**负责推送新闻

​	通过 管理线程类 取到所有的线程   取到当前所有在线用户的线程 再取出Socket 通过message传递过去



**离线发消息**

​	服务器端再单独做个集合存放离线的message                            集合用ConcurrentHashmap

​	key为 接收者id   value为ArrayList

​	如果发送消息时用户不在线就存放

​	当服务器端发现客户端登录成功后，就查找数据库里有无他的id的ArrayList，如果有的话就遍历这个ArrayList取出消息进行发送， 就到集合里去看有没有接收者id为上线的用户的，如果有的话就取出ArrayList里的message

​	同时把这个id从集合中删除

